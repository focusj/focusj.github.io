## 事务特性

事务的四个特性：原子性（A），一致性（C），隔离性（I)，持久性（D），这些知识在数据库课程中已经了解过了。我们再来通过银行转账的例子（A账户向B账户转1000块钱）再来赘述一下这四个特性。

1. 转账过程扣减A账户，增加B账户这两个过程要么全执行，要么都不执行，不能只发生其一；
2. 转账成功，A账户比原来少1000块，B账户多1000块（保证业务的正确性）；
3. 转账成功，两个账户最新的状态应该被永久的记录下来，即A给B转1000块这个事实既然已发生就不能被抹去或丢失；
4. 在A给B转账的同时，C也给B转账，两个转账操作应该按照发生时间依次执行。

一致性可以理解为业务层面的正确状态。原子性，隔离性这两个特性也是为了保证一致性。

## 事务隔离级别

为了保证并发读写的正确性，提出了事务隔离级别。不同的隔离级别产生的效果是不一样的。

| 隔离级别 | 脏读 | 不可重复读 | 幻读  |
| :----: |:----:|:--------:| :---:|
| 读未提交 | 是   | 是       |  是 |
| 读已提交| 否 | 是 | 是 |
| 可重复读| 否 | 否 | 是 |
| 串行事务| 否 | 否 | 否 |

读未提交（Read Uncommitted）：允许产生脏读。脏读是读到其他事务的中间（未提交）状态。
读已提交（Read Committed）：只能看到已经提交的事务的状态。不能保证重复读。
可重复读：一个事务多次执行同一个查询，期间其它事务对数据修改并提交，导致前一个事务同一个查询读取到的数据是不一致的。
串行事务：串行事务隔离级别最高，每个事务依次执行。

不可重复读的重点是update和delete，幻读的重点是insert。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

## MySQl内部锁机制



当前读：update，delete中的where

快照读：select是快照读。
