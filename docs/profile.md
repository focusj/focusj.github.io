## 个人信息

- 王康 / 男 / 5年 工作经验 / 本科
- 电话：18610842638 
- Email：focusj.x@gmail.com
- Blog：http://www.jianshu.com/users/13542edebea3/
- Github：https://github.com/focusj

## 工作经历

2016年03月~至今         北京三石信息科技有限公司  后端工程师

2014年10月~2015年11月   ThoughtWorks          全栈工程师

2012年04月~2014年09月   北京尤尼信息科技有限公司  全栈工程师

## 技术总结

- 擅长Java, Scala. 熟悉其常用的集合类;了解Java多线程编程和Scala Actor并发模型;了解常见垃圾回收算法及其工作机制. 

- 了解Python, JavaScript, C#. 

- 框架和工具： Spring Boot, Akka, Vert.x, Play FrameWork, Netty, JOOQ, MongoDB, MySQL, RabbitMQ, Redis. 


## 项目经验

### 电商后端服务拆分

*职责*: 负责人

*技术选型*: Java8, Vert.x, JOOQ, MySQL, Redis, Docker

*项目背景*
第三石是作二手交易的创业公司, 公司成立三年以来尝试了很多不同的业务, 这些业务都运行在一个基于Python的系统里. 由于缺少重构和优化, 现在系统里到处充斥着垃圾代码. 还有为了追赶项目进度, 技术也做了很多架构和实现上的折中. 综上这些因素导致系统臃肿复杂, 开发维护成本越来越高. 而且还存在严重的性能问题. 

为了解决这些问题, 开始着手服务的拆分工作. 在电商业务里, 用户和商品是最核心的两个领域模型. 所以, 服务拆分的第一步是先把用户和商品剥离出去. 然后再逐步把其他业务独立出去. 

构建用户和商品服务需要考虑以下因素：这是最底层的两个系统, 几乎所有的外围系统都会调用这两个系统. 因此要求这两个系统必须要具备高可用, 低延迟, 并且要能够容纳大访问量. 否则就会导致整个服务变慢或不可用. 因此我们选择Vert.x作为基础框架. Vert.x是基于Netty, 采用事件驱动的异步框架. 使用它可以使用较少的资源支撑大量的并发访问，因为用户请求等待过程会释放CPU. 高可用方案是每个服务部署多节点, 前边挂AWS的ELB. 部署使用Docker. 

*用户系统实现细节*
1. 请求协议的设计: `{"path": "/users/getById", "arguments": {"user_id": 510,  filter:["nickname"]}, "context": {"id": uuid, "token": ""}}`. path是请求的api地址;arguments是该api需要传入的参数;context是请求的上下文信息, 包括唯一的request id（便于作请求log聚合）, token授权信息. 

2. API设计的原则：简单, 无业务. 简单和无业务的API可以让不同服务消费方通过组合不同的API来实现不同的业务需求, 也可以防止服务提供方API爆炸. 

3. 服务的迁移. 老系统向新系统迁移的时候, 实现了控制逻辑. 一方面能够控制哪些用户可以使用新的用户服务, 另一方面可以控制打开用户服务的读还是写. 这样可以确保服务的平滑迁移, 即使有问题也尽量影响少部分的用户. 

### 订单系统

*职责*: 系统设计, 开发和维护

*时间*: 2016/5 ~ 今

*技术选型*: Java 8, Spring Boot, Spring Statemachine, JOOQ, Akka, Flyway, RabbitMQ, Redis, MySQL

5miles主要在美国市场是长做C2C的业务, 主要是二手商品交易. 用户在平台发布商品, 如果达成买卖意向, 则用户自行线下交易. 为了让用户更安全方便的买卖物品, 去年公司决定要做担保交易和物流. 为满足这个业务公司开发新的订单系统.

*项目经历*：
1. 基于rest的微服务架构. 微服务架构的一个优点是不限制服务的技术栈, 每个服务都可以选择合适的技术栈. 但是实施微服务的成本也非常高. 跨服务的调用增多带来潜在的性能和稳定性问题. 拿下单流程来说, 下单时需要调用用户系统获取买家卖家用户信息, 商品系统获取商品信息, 然后再调支付系统扣款. Http调用的时间成本要高于代码直接调用, 这导致了下单接口非常慢, 通常需要3s左右. 为了提升下单的速度, 对获取用户, 商品信息这些Http调用使用CompletableFuture做了并行处理; 然后对不影响下单主流程比如发push和扣费小票这些操作作异步处理. 经过这些优化, 下单接口速度提升到1s左右. 对于稳定性问题: 一方面增加各个服务的可用性;另一方面在一些业务场景加入了重试和对账机制, 对于有问题的数据人工处理.

2. 基于akka实现异步任务处理. 在我们很多业务场景中都需要向用户发送push提醒, 一般发送push不会影响业务主流程, 因此可以作成异步处理. 还有, 使用RabbitMQ进行系统间通信时也可以实现为异步. 目前对这两类操作都进行了Actor改造. 为了确保不会丢失消息, 使用了akka persistent Actor. 由于Actor本事是单线程工作, 为了增加处理效率每个Actor都配置了Router方式部署的worker. 当master向worker分发消息时使用了At-Least-Once Delivery, 这样确保了消息的送达性.

3. 基于Redis实现的分布式锁.

4. 使用Spring Statemachine实现订单状态流转.

### 名称：业务处理系统

*职责*：全栈开发

*时间*：2014/10 ~ 2015/11

*技术选型*：.Net Web API, ReactJS, SQL Server

该项目是ThoughtWorks为某美国公司开发的业务处理系统. 公司主要负责财务审计, 国际报税等业务. 目前公司有一个系统供企业内部人员处理订单. 为了方便合作公司查看订单处理状态, 并且能够参与一些简单的业务处理环节, 该公司需要定制开发一个独立的系统. 之前的内部系统提供新系统需要的所有API.

*项目经历*：
1. 用Pact确保系统间的集成. 我们构建的每一个系统都依赖于核心系统的API. 由于核心系统也在不断的开发新功能, 我们正在使用的API很有可能被别人修改, 导致系统挂掉. 为了解决这个问题, 我们引入了PactNet. PactNet是一个契约测试库, 我们作为消费端会递交给核心系统一份JSON格式的接口契约文件, 用以标记我们需要哪些API, API的参数, 以及响应结果. 这样核心系统开发人员在做API修改时, 会检查被修改过的API是否还满足我们的要求, 确保API的兼容性.

2. 用ReactJS解决前端控件复用的问题. 该项目由多个子站点构成, 而且每个子站点的前端展示和交互是统一的. 如果每个站点都各自实现类似table, input, select等这些组件的话, 就会导致大量的重复代码. 并且目前有多个团队在并行开发, 每个团队的实现方式也不尽相同. 这是极不利于后期维护和升级的. 因此我们用ReactJS封装了一些通用的前端控件, 这样不仅解决了后期的维护问题, 而且节省了很多开发工作.

3. 使用redis做session管理. 我们的web站点使用WIF作登录认证, 每次用户登录时都会向WIF Server申请登录令牌(token). 这个token有一个存活时间, 在这段时间内token总是有效的, 只有当token过期时WIF Server才会重新生成新的token. 即使logout, 该token仍然可以使用. 由于token以cookie的形式存储在浏览器, 所以token存在被盗的可能, 一旦拿到该token我们所有依赖WIF Server认证的站点都受到威胁. 而且每个站点还提供了token续期的功能, 如果某个用户拿到了这个token, 并且知道了token续期的API, 那么这个用户就可以无限期的使用系统了.
出于安全的考虑, 我们引入了redis来管理token. 当WIF生成一个新的token时都会把这个token存储到redis中, 用户访问网站时每次都会检查redis中是否存有该token. 当用户logout时把该token从redis中移除, 通过这种机制保证了只要用户logout, 这个token便失效.


#### 名称：移动社交App服务端

*职责*：各个功能模块的设计与实现

*时间*：2013/6 ~ 2014/9

*技术选型*：Scala, Akka, play2, MongoDB, AWS

*项目简介*：该App是一款即时通讯工具, 你可以通过绑定自己不同的社交账号发现更多的人, 并把他们加入自己的通讯录, 实现跨平台通讯.

*项目经历*：
1. 选用WebSocket来确保消息传递的实时性和可靠性. 第一版后端服务基于Http协议, 前端用轮寻的方式来获取最新消息. 这种实现方式缺点比较明显：轮寻速度过快会增加后端服务的压力; 过慢会造成聊天体验下降. 并且我们系统中还会有用户信息和好友关系的更新历史, 这些数据都需要前端定期的读取. 为了更好的实现服务端向客户端推送数据我们引入了WebSocket. 当用户收到新消息时, 首先判断该用户是否在线, 如果用户在线则把消息push到前端; 如果用户不在线则把消息存为历史, 当用户上线时把所有的历史推送给前端.

2. 关系模块的设计. 我们系统中很多操作都需要依赖好友关系, 比如说查看好友列表, 创建会话. 我们把好友关系抽象为类似于图的数据结构, 通过判断两个节点间的连通性来判断好友关系是否存在. 比如A账号想要和B账号创建会话, 前端会传递这样的路径：A > B, A > C > B（A, B, C代表微博用户）. 对于这种情况我们首先会验证A账号是否被当前登录用户绑定, 然后分别检查A, B, C之间是否存在好友关系. 任何一个环节验证失败, 该验证则失败. 最复杂的一种情况是跨平台创建对话, 比如新浪微博用户要和Facebook用户创建对话, 这种情况下路径是这样：A > C > D > B（A, C, 是新浪微博用户; B, D是Facebook用户）. 判断C和D是否连通的条件是C, D账号是否被一个用户绑定.

3. 用户信息和好友关系更新模块. 我们所有的用户信息和好友关系都是从各个社交平台读过来的, 为了确保数据一致性, 需要对这些关系和用户信息做定时更新. 我们最初的做法是使用定时任务, 每隔一段时间触发更新任务, 对数据库中的关系和信息统一更新. 这种做法有一个问题, 并不是所有的关系和信息都需要更新, 不经常上线的用户为他们更新关系和历史其实是一种浪费. 而且, 每个社交平台开放API的token都有次数使用限制.
由于上述问题, 我们修改了实现方式：把触发更新的点放到读取用户信息和关系时. 每次前端读取用户信息或关系, 都会向负责更新的Actor发送一条消息. Actor内部会依据上次更新时间判断该用户是否可以更新. 通过这种方式我们做到了只更新活跃用户的数据, 节省了token的用量. 还有, 当更新A账号时, 假如发现A新增了B好友, 这时会作一个判断, 假如B也在我们应用绑定过, 也会把这个更新推送给B用户.

## 期望工作
Java工程师; Scala工程师; 后端开发