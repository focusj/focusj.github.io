# JVM类加载

## Class生命周期

类的生命周期及各个阶段的工作. JVM必须按照图中的规定的流程工作. 比如初始化一个类之前一定要经过类的装载验证准备解析等工作.

![class-life](../images/class-life.png)

### 装载

装载是装载class文件. 对于装载阶段JVM没有明确的规定何时进行装载. 类装载的过程：

- 通过类的全限定名获取类的二进制字节流.
- 转换成方法区的运行时结构.
- 在堆空间中创建一个Class对象，作为方法区这个类的访问入口.

### 验证

验证的主要工作是验证class文件的合法性. 通常这一步是非常麻烦的，如果想要关闭这一步可以通过-Xverify:none跳过.

- 文件格式验证. 包括: 是否以0xCAFEBABE开头，主次版本号是否能够被当前虚拟机执行, 不被支持的常量类型, 文件中是否包含不符合utf-8规范的数据.
- 元数据验证. 是否有父类，是否继承了不能被继承的类，是否实现了父类和接口的所有方法，字段和方法是否和父类矛盾.通常这些问题在编码的时候都能够通过编译找到问题.
- 字节码验证. 确定程序是合法的, 符合逻辑的.
- 符号引用验证. 主要是对自身以外的信息进行匹配校验.(比如字段，类，方法的可见性是否可以被当前类访问).

### 准备

准备阶段是为类变量(静态变量)分配内存，并设置类变量的初始值.这个阶段不会对变量赋值，类变量的赋值是放在类构造器`<clinit>()`方法中，这是在初始化阶段作的. final字段的赋值是在编译阶段确定的.

### 解析

解析阶段是虚拟机将常量池中的符号引用改为直接引用. 这个过程会递归的把对其它类的引用load到jvm中. 符号引用只是一个标识，很可能符号引用的目标还未load入虚拟机. 直接引用可以是直接指向目标的指针，相对偏移量，或一个定位到目标的句柄.(我理解应该是这个过程应该是链接到jvm内存中A.b的内存地址，比如常量池中的一个句柄)

a)类和接口解析.如果引用了其他的类，则直接走老一套的类加载阶段.
b)字段引用.当前类搜索 -> 父类和接口 如果可以找到则返回，如果到了Object都没有找到则NoSuchFieldException.
c)类和接口方法查找.

### 初始化

#### 触发一个类进行初始化的几个条件

- JVM遇到了以下指令：new，getstatic，putstatic，invokestatic.

在实际应用场景中对应：
1. 创建一个Java类的实例。如`MyClass obj = new MyClass()`.
2. 调用一个Java类中的静态方法。如`MyClass.sayHello()`. 当访问一个Java类或接口中的静态域的时候，只有真正声明这个域的类或接口才会被初始化。
3. 给Java类或接口中声明的静态域赋值。如`MyClass.value = 10`.
4. 访问Java类或接口中声明的静态域，并且该域不是常量。如`int value = MyClass.value`.

- 通过反射实例化一个类.
- 初始化类的时候如果发现其父类没有被初始化.
- 虚拟机启动是包含入口函数的那个类.
- 调用java.lang.invoke.MethodHandle返回的结果是REF_getStatic，REF_putStatic，REF_invokeStatic，REF_newInvokeSpecial.且对应的类没有经过初始化，则对其进行初始化.

#### JVM执行Class初始化的过程

初始化阶段是执行`<clinit`>()的过程.`<clini`t>()是所有类变量赋值和static{}语句块合并产生的，其顺序取决于code源文件中的顺序.

在调用当前类的<clinit>()之前，JVM会保证先去执行父类的<clinit>()，所以jvm中第一个执行的<clinit>()一定是Object的.

如果类或接口中没有静态语句块或没有变量的赋值操作，那么编译器可以不生成<clinit>()方法.

执行接口的<clinit>()时不用先执行父接口的<clinit>()方法，只有当调用其变量时才调用.

虚拟机会保证在并发环境下<clinit>()的正确执行.

## 类加载器

类加载器是加载Class的工具类，在JVM中总共有三类加载器：

- BootStrap加载器, 它是JVM自己实现的, 用于加载JAVA_HOME/lib/目录中, 或者被-Xbootclasspath参数所制定的路径.
- Extension加载器, 负责加载JAVA_HOME/lib/ext目录下, 或者被java.ext.dirs系统变量制定的路径中的类库.
- Application加载器, 这个类有sun.misc.Launcher$AppClassLoader实现, 这个类加载器是ClassLoader.getSystemClassloader的返回值. 这个类加载器负责加载用户路径上所制定的类库.
- 用户自定义类加载器. 

类加载器的一个重要用途是在JVM中为相同名称的Java类创建隔离空间。在JVM中，判断两个类是否相同，不仅是根据该类的二进制名称，还需要根据两个类的定义类加载器。只有两者完全一样，才认为两个类的是相同的。
