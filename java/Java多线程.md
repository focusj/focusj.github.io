### sleep，yield，wait，wait各个函数的区别？

- sleep  

使当前执行的线程暂停执行一段时间，让出CPU。sleep可以使低优先级的线程得到执行的机会。  

但是不会释放共享数据上的锁，所以其他线程仍然不能访问该共享数据。

- join  

join方法是调用该方法的线程在该线程执行完后才开始执行。比如，在main函数中我们调用了threadA.join()，main线程会在Thread A执行完成后才继续执行。

- yield  

和sleep方法类似，调用线程让出CPU，但是不能由用户制定暂停多长时间按，yield方法只能让同优先级的线程有执行的机会。

- wait，notify，notifyAll

这三个方法都是Object中的方法。wait表示当前线程暂停执行，并且释放共享数据的锁，让其他线程可以进入synchronized数据块，当前线程被放入共享数据的等待池中。当调用notify之后从等待池中随即选取一个线程执行。  

notifyAll则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池。



### interrupt函数

每个线程都有一个与之相关联的 Boolean 属性，用于表示线程的中断状态（interrupted status）。中断状态初始时为 false；当另一个线程通过调用 Thread.interrupt() 中断一个线程时，会出现以下两种情况之一。如果那个线程在执行一个低级可中断阻塞方法，例如 Thread.sleep()、 Thread.join() 或 Object.wait()，那么它将取消阻塞并抛出 InterruptedException。

（我的理解：线程内部有一个属性用来设置interrupt状态，当interrupt状态被设置为true，该线程再去执行sleep，wait这些阻塞方法的时候将抛出InterruptedException。一个线程应该作出正确的中断行为）



### 定律

- Amdahl定律：Gene Amdahl 发现在计算机体系架构设计过程中, 某个部件的优化对整个架构的优化和改善是有上限的。// 即使你有10个老皮也不能一个月把孩子生下来。

- 摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。



### 现代的CPU架构

现代的计算机系统都加入了一层和处理器运算速度相似的高速缓存（Cache）层来作为内存和处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步到主内存中。



在多核处理器中，每个处理器都有自己的高速缓存，它们都通过主内存共享数据。为了充分利用处理器的运算单元，处理器可能会对输入的代码进行乱序执行优化，然后在执行完成后进行结果重组，保证结果和顺序执行的结果是一致的。但是并不能保证各个语句的计算顺序和其代码顺序一致。



### Java内存模型

Java内存模型的作用是屏蔽掉各种硬件和操作系统的内存访问差异，以实现Java在各个平台下都能达到一致的并发效果。



### 主内存和工作内存

所有的变量都存储在主内存中，每条线程都有自己的工作内存。

工作线程保存了主内存变量的拷贝，变量在工作内存中修改完毕之后写入主内存。不同的线程之间是无法访问彼此工作内存中数据的。



### Volatile变量

volatile是Java虚拟机中最轻量级的同步机制。它有两个特性：1.此变量对所有线程的可见性；2.一条线程修改了这个变量的值，新值对于其他线程来说是立即可见的。



volatile的适用场景：

- 运算结果并不依赖变量的当前值，或者能够确保只有单一线程修改变量的值。

- 变量不需要与其他状态共同参与不变约束。

实例：状态控制

```

volatile boolean shutdownRequested = false;



public void shutdown() {

  shutdownRequested = true;

}



public void run() {

  while(!shutdownRequested) {

    // ...

  }

}

```



### 数据安全程度

按照线程的安全程度，可将Java中各种操作共享的数据分为以下几类：不可变，绝对线程安全，相对线程安全，线程兼容，线程对立。



不可变，是最安全的，在任何环境下它的数据都是不可便的。Scala提倡使用不可便对象



绝对线程安全的要求是，不论在什么环境下运行，调用者都不需要采用额外的同步措施。java.util.Vector都不能达到这个级别。



相对线程安全，需要保证对这个对象单独操作是线程安全的，不需要作额外的保障，但是对于一些有序的操作则需要额外的同步机制。Vector，HashTable，这些内置的线程安全类属于这个级别。



线程兼容的类，本身是线程不安全的。绝大多数的Java类属于这个级别。



### 线程安全的实现方法

1. 互斥同步

在对线程同时访问数据时，保证同一时刻只有一个线程访问该数据。临界区，互斥量，信号量都是这种措施的实现。它属于悲观并发策略。



synchronized关键字经过编译之后，会在同步块的前后形成monitorenter和monitorexit两个字节码指令，这两个字节码需要一个reference类型的参数来标明需要解锁和锁定的对象。如果没有制定则去synchronized所在的当前对象。



synchronized可以重复嵌套使用，对应的monitorenter和monitorexit是可以重复进入的。



synchronized和ReentrantLock的区别？





2. 无阻塞同步

基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用数据，则操作成功，如果有其他线程争用数据，产生了冲突，则不断进行重试。



CAS操作是硬件支持的指令。



LockFree算法：

1. 循环

2. CAS (CompareAndSet)

3. 回退



Unsafe支持的compareAndSet，AtomicInteger和AtomicLong



3. 无同步方案

- 可重入代码。指的是Scala中的纯函数。

- 线程本地存储。ThreadLocal类。

