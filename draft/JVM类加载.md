# JVM类加载

### JVM 类加载

类的生命周期及各个阶段的工作.JVM必须按照图中的规定的流程工作.比如初始化一个类之前一定要经过类的装载验证准备解析等工作

![class-life](../images/class-life.png)

#### 装载

对于装载阶段JVM没有明确的规定何时进行装载.

类装载的过程：

- 通过类的全限定名获取类的二进制字节流
- 转换成方法区的运行时结构
- 在堆空间中创建一个Class对象，作为方法区这个类的访问入口.

#### 验证

验证的主要工作是验证class文件的合法性.通常这一步是非常麻烦的，如果想要关闭这一步可以通过-Xverify:none跳过.

- 文件格式验证.(是否以0xCAFEBABE开头，主次版本号是否能够被当前虚拟机执行, 不被支持的常量类型, 文件中是否包含不符合utf-8规范的数据)
- 元数据验证.(是否有父类，是否继承了不能被继承的类，是否实现了父类和接口的所有方法，字段和方法是否和父类矛盾.通常这些问题在编码的时候都能够通过编译找到问题).
- 字节码验证. 确定程序是合法的, 符合逻辑的.
- 符号引用验证.主要是对自身以外的信息进行匹配校验.(比如字段，类，方法的可见性是否可以被当前类访问).

#### 准备

准备阶段是为类变量分配内存，并设置类变量的初始值.这个阶段不会对变量赋值，类变量的赋值是放在类构造器<clinit>()方法中，这是在初始化阶段作的.Final字段的赋值是在编译阶段确定的.

#### 解析

解析阶段是虚拟机将常量池中的符号引用改为直接引用.这个过程会递归的把对其它类的引用load到jvm中.符号引用只是一个标识，很可能符号引用的目标还未load入虚拟机.直接引用可以是直接指向目标的指针，相对偏移量，或一个定位到目标的句柄.(我理解应该是这个过程应该是链接到jvm内存中A.b的内存地址，比如常量池中的一个句柄)
a)类和接口解析.如果引用了其他的类，则直接走老一套的类加载阶段.
b)字段引用.当前类搜索 -> 父类和接口 如果可以找到则返回，如果到了Object都没有找到则NoSuchFieldException.
c)类和接口方法查找.

#### 初始化

触发一个类进行初始化的几个条件：

- JVM遇到了以下指令：new，getstatic，putstatic，invokestatic.在实际应用场景中对应：new一个class，访问/设置一个对象的静态变量，调用一个类的静态方法.
- 通过反射实例化一个类.
- 初始化类的时候如果发现其父类没有被初始化.
- 虚拟机启动是包含入口函数的那个类.
- 调用java.lang.invoke.MethodHandle返回的结果是REF_getStatic，REF_putStatic，REF_invokeStatic，REF_newInvokeSpecial.且对应的类没有经过初始化，则对其进行初始化.
(通过子类访问父类中的静态字段只会出发父类的初始化；常量在编译期间已经存储到类的常量池中, 所以对常量的引用不会出发类的初始化)

初始化阶段是执行<clinit>()的过程.<clinit>()是所有类变量复制和static{}合并产生的，其顺序取决于code源文件中的顺序.

在调用当前类的<clinit>()之前，jvm会保证先去执行父类的<clinit>()，所以jvm中第一个执行的<clinit>()一定是Object的.

如果类或接口中没有静态语句块或没有变量的复制操作，那么编译器可以不生成<clinit>()方法.

执行接口的<clinit>()的时不用先执行父接口的<clinit>()方法，只有当调用其变量是才调用.

虚拟机会保证在并发环境下<clinit>()的正确执行.



### 类加载器

类加载器是加载Class的工具类，ClassLoader有两类：Extension ClassLoader，BootStrap ClassLoader，Application ClassLoader.BootStrap是JVM的一部分，由C++实现.User ClassLoader是由Java语言实现，并继承自ClassLoader.

### 字节码执行

JVM栈帧结构：
![jvm-stack.png](../images/jvm-stack.png)

a)栈帧结构
i.局部变量表.
局部变量表用于存储了方法的参数和方法内的局部变量.方法在编译阶段就确定了表的大小，并写入到class文件中.
局部变量表的容量以槽为单位.每个槽的基本容量是32个字节，java中除了Double和Long要用到两个槽，其他基本类型都是32个字节.

![local-variables.png](../images/local-variables.png)

ii.操作数栈.
操作数栈是后如先出的数据结构.字节码的执行就是在操作数中执行的，操作数栈可以理解为线程工作的车间.而局部变量表可以当作仓库，当线程(worker)工作的时候需要什么东西会从仓库中要，然后加工完了之后再返回仓库.
iii.动态链接
每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个应用是为了支持方法调用过程中的动态链接.类比类加载阶段的链接操作，在函数执行的时候没有解析的链接仍然需要去做.有仍然
iv.方法返回地址
方法退出之后需要返回到方法被调用的位置，这样程序才能继续执行(这有可能是程序PC计数器的一个行号).