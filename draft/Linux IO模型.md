# Linux IO 模型

## 补充基础知识

### 文件描述符

在Linux操作系统中，所有的外部设备都抽象成文件对待，对一个文件的读写操作会调用内核提供的指令，返回一个文件描述符。文件描述符其实就是以非负整数命名的一些文件。我们可以查看/proc/${pid}/fd/目录下一些运行的进程的所有文件描述符。每个进程的文件描述符是隔离的，可以理解进程ID是其命名空间。POSIX定义了三个固定fd，STDIN_FILENO，STDOUT_FILENO和STDERR_FILENO三个常量，分别是0，1，2。

通过命令`ulimit -n`可以查看当前系统的文件打开数。如果进程创建超过这个数量的文件，则会出现`too many open files`错误。通常web server或者socket server服务多个client的时候会出现这个问题。

### Page Cache

页缓存（Page Cache）是位于内存和文件之间的缓冲区，它实际上也是一块内存区域，所有的文件IO（包括网络文件）都是直接和页缓存交互，操作系统通过一系列的数据结构，比如inode, address_space, struct page，实现将一个文件映射到页的级别，这些具体数据结构及之间的关系我们暂且不讨论，只需知道页缓存的存在以及它在文件IO中扮演着重要角色，很大一部分程度上，文件读写的优化就是对页缓存使用的优化。

### IO过程

以read举例，描述IO的详细过程。用户进程发起read 系统调用，数据会先被拷贝到操作系统内核的缓冲区中（数据的来源可能是fs，也可能是网络，如果是网络则会发生阻塞），然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：

1.等待数据准备
2.将数据从内核空间拷贝到用户空间中

第一步根据其是否阻塞调用进程可以分成：阻塞和非阻塞IO；第二步根据其是否阻塞调用进程分为：同步和异步IO。

下边就以这两个指标衡量Linux中的集中IO模型。

#### 同步阻塞（read/write）

在整个IO操作中用户进程被block，直到数据被拷贝到用户空间，或者产生错误。这种IO模型我们可以记为：同步-阻塞IO。

![blocking-io-model](../images/blocking-io-model.png)

#### 异步非阻塞（O_NONBLOCK）

在linux中我们通过设置O_NONBLOCK，打开其非阻塞模式。这样用户进程发其read操作，如果内核中数据还没有ready，会立即返回错误(E_WOULDBLOCK)，应用程序可以一直循环这个操作知道数据可用。然后程序再次发起一个系统调用把数据拷贝到用户空间（这个阶段仍会阻塞用户进程）。这种IO模型我们可以记为：异步-阻塞IO。

#### 异步阻塞（多路复用）

linux中通过select，poll，epoll实现多路复用技术。用户进程通过讲fd传递给select或者poll系统调动，等待其中的任何一个fd变成就绪状态。select和poll是顺序的扫描fd是否就绪，并且支持的fd数量有限(用数组保存fd)。epoll通过时间机制，当fd就绪时出发回调函数。select过程用户进程仍会被阻塞，当数据ready向用户空间拷贝数据的时候用户进程再次阻塞。这种IO模型我们可以记为：同步-阻塞IO。

这种IO模型的优势在于处理大量的fd，例如Netty中就实现了基于Select和Epoll的两种IO模型。

![multiplexing-io-model](../images/multiplexing-model.png)

#### 异步IO（AIO）

用户发起read操作之后，便立即返回。当数据ready并且拷贝到用户空间之后，系统内核给用户进程发送一个信号，告知read操作完成。整个过程用户进程都没有被阻塞。这种IO模型我们可以记为：异步-非阻塞IO。

![asynchronous-io-model](../images/asynchronous-io-model.png)

### 关于同步/异步，阻塞/非阻塞

同步/异步：从调用者角度来说。比如我同步的调用一个Remote API，这意味着用户程序会一直阻塞直到返回结果。我们也可以使用多线程编程技术，把这个调用封装成一个异步调用。

阻塞/非阻塞：从服务提供者角度来说。仍以上边的Remote API举例。阻塞是直到准备好了结果才返回，非阻塞是调用之后立即返回，当结果准备好了以某种方式通知调用者（实现这种方式要更换协议了）。
