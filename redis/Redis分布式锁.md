# Redis分布式锁

## 单节点的锁如何获取

加锁:
```
SET lock-name random-value-for-this-lock NX PX 3000
```

解锁:
```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

注意事项: 

- 获取锁的命令应是原子性的, 或者用lua脚本, 使用上边说的加锁命令. 如果set和expire分开执行, 可能会造成状态不一致. 比如执行set命令后程序crash了, 那么锁就永远不能被释放.

- random value确保每个获取锁的客户端持有的value是不一样的. 防止自己的锁被别人给释放了.

- timeout时间一定要正确的设置. 正确说的是: 不会太短, 程序还未完成锁就被删除；不会太长, 导致其他的客户端不能获取锁. 

- unlock一定要用lua脚本. 分开执行的话可能会造成锁混乱: 如果程序A get value并判断toke相等, 这时程序发生了较长的停顿, 停顿事件超过了锁的有效时间, 程序B这时获取锁成功, 当前程序恢复过来删除key的时候, 其实把B的锁删掉了.

## 针对多节点的RedLock

单节点Redis无法保证高可用, 那么启动多个Redis节点, 上边的算法还能用吗? 不能. 举个例子: A在Master节点获取了锁, 随后Master挂掉, lock还没有同步到Salve上, 这时B又在Slave上获取了相同的锁, 导致锁冲突. 所以, 针对多节点Redis架构, 需要一种新的算法来实现分布式锁. 这就是RedLock. 

算法内容如下：

1. 获取当前系统时间.

2. 按顺序依次向N个Redis节点发起获取锁的命令. 命令要设置一个合理的超时时间, 否则如果一个节点故障很可能造成获取锁阻塞. 如果一个Redis获取失败, 则立即转到下一个节点.

3. 计算从各个节点获取锁总共消耗了多少时间：当前时间 - 第一步的时间. 如果客户端从多余N/2+1个节点成功获取了锁, 并且时间差大于0, 则获取锁成功, 否则都为失败.

4. 计算锁的有效时间 = 最初的锁的有效时间 - 获取锁的消耗时间.

5. 如果锁获取失败了,则向所有的节点发起释放锁的命令.

unlock阶段则向所有的节点发送释放锁的命令. 

## 质疑

整个算法思路比较清晰, 也很好的解决了上边提到的锁冲突的问题. 但是针对RedLock Martin Kleppmann和antirez之间有过一场争论. 

#### 场景一

Martin: 考虑以下情况: A,B,C,D,E五个节点, 假设客户端1获取了ABC三个节点上的锁, 这时C挂了, 但是C还没有持久化, 这时C节点重启, 客户端2在CDE上获取锁. 

antirez: 提出了延迟重启的概念, 一个节点崩溃后, 先等上一段事件, 这个时间 > 锁的有效时间.

### 场景二: 关于锁冲突

客户端1在获得锁之后发生了很长时间的GC pause, 在此期间, 它获得的锁过期了, 而客户端2获得了锁.当客户端1从GC pause中恢复过来的时候, 它不知道自己持有的锁已经过期了, 它依然向共享资源（上图中是一个存储服务）发起了写数据请求, 而这时锁实际上被客户端2持有, 因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）.

![redis-lock-conflict](../images/redis-lock-conflict.png)


优化方案: 基于fencing token的优化
![redis-lock-fencing-token](../images/redis-lock-fencing-token.png)

### Martin的高见

- 对于锁的分类
Ａ. 为了效率. 协调各个客户端避免重复的工作. 容忍锁失效.
Ｂ. 正确性. 这种情况下不允许锁失败．

- 基于zookeeper的分布式锁
1. 客户端创建一个znode节点/lock, 如果成功则该客户端获取锁成功. 其他客户端在尝试创建的时候会失败
2. 持有锁的客户端完成任务时候删掉/lock, 释放该锁. 其他客户端尝试获取锁便会成功.
3. znode应该设置成ephemeral, 它能保证如果创建znode的那个客户端崩溃（和server失联）则该node会自动删除.

相比于Redlock, 这个锁没有过期时间.但是这种方式仍然有它的问题, zookeeper的自动删除机制是这样实现的. 每个客户端和zookeeper之间维护着一个Session. 如果server长时间收不到客户端的心跳那么就认为该客户端是过期的. 通过这个session创建的所有ephemeral节点会被自动删除. 看一下这个场景：
1. C1创建znode节点/lock, 成功获取了锁.
2. C1进入长时间的pause.
3. Zookeeper端认为该client已经失效然后删了它创建的节点.
4. C2获取同样一把锁.
5. C1恢复过来之后仍然感觉自己持有锁.（锁状态错误）

- Fencing token
Fencing token是为了解决上述提到的问题而提出的方案. 在被锁保护的资源server上维护一个递增的fencing token, 获取锁的时候同时拿到当前分配的token, 再操作资源的时候会主动放弃持有旧的token的client.
